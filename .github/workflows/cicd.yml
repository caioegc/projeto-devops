name: CI/CD Pipeline

# Trigger: executa a cada push na branch main
on:
  push:
    branches: [ main ]

# Vari√°veis de ambiente globais
env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  IMAGE_NAME: flask-tasks-app

jobs:
  # Job 1: Execu√ß√£o dos testes unit√°rios
  test:
    runs-on: ubuntu-latest
    
    # Servi√ßo do PostgreSQL para testes de integra√ß√£o
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: tasks_db
          POSTGRES_USER: app_user
          POSTGRES_PASSWORD: app_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Wait for PostgreSQL
      run: |
        sleep 10  # Aguarda o PostgreSQL inicializar

    - name: Run tests
      run: |
        cd app
        python -m pytest test_app.py -v  # Executa todos os testes com verbose

  # Job 2: Provisionar Infraestrutura com Terraform (PARTE NOVA)
  provision-infra:
    needs: test  # Espera os testes passarem
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Debug - In√≠cio do job provision-infra
      run: echo "üöÄ provision-infra iniciado em $(date)"

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.14.0

    - name: Configure AWS Credentials for DigitalOcean Spaces
      run: |
        echo "AWS_ACCESS_KEY_ID=${{ secrets.SPACES_ACCESS_KEY_ID }}" >> $GITHUB_ENV
        echo "AWS_SECRET_ACCESS_KEY=${{ secrets.SPACES_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV

    - name: Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: Terraform Plan (Debug)
      working-directory: ./terraform
      run: terraform plan -no-color
      env:
        TF_VAR_do_token: ${{ secrets.DO_TOKEN }}

    - name: Terraform Apply
      working-directory: ./terraform
      run: terraform apply -auto-approve
      env:
        TF_VAR_do_token: ${{ secrets.DO_TOKEN }}

    - name: Get Droplet IP
      id: terraform-output
      working-directory: ./terraform
      run: |
        # Executa terraform output e captura apenas a primeira linha (IP)
        IP=$(terraform output -raw -no-color droplet_ip 2>&1 | head -n 1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+')
        if [ -z "$IP" ]; then
          echo "‚ùå Falha ao obter IP do Terraform. Sa√≠da do comando:"
          terraform output -raw droplet_ip 2>&1
          exit 1
        fi
        echo "droplet_ip=$IP" >> $GITHUB_OUTPUT
        echo "üì° IP obtido do Terraform: $IP"

    - name: Save IP for next job
      run: |
        echo "${{ steps.terraform-output.outputs.droplet_ip }}" > droplet_ip.txt
        echo "üìÅ IP salvo em droplet_ip.txt: $(cat droplet_ip.txt)"

    - name: Upload IP as artifact
      uses: actions/upload-artifact@v4
      with:
        name: droplet-ip
        path: droplet_ip.txt
        retention-days: 1

    - name: Debug - Fim do job provision-infra
      run: echo "‚úÖ provision-infra conclu√≠do em $(date)"

  # Job 3: Build e push da imagem Docker (s√≥ executa se os testes passarem)
  build-and-push:
    needs: test  
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'  
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: |
          ${{ env.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          ${{ env.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}  
        cache-from: type=registry,ref=${{ env.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
        cache-to: type=inline

  # Job 4: Deploy autom√°tico no servidor (AGORA USA IP DO TERRAFORM)
  deploy:
    needs: [build-and-push, provision-infra]  # Depende dos dois jobs
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'  
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download IP artifact
      uses: actions/download-artifact@v4
      with:
        name: droplet-ip
        # Se n√£o encontrar o artifact, falha explicitamente
        if-no-found-files: error

    - name: Read Droplet IP
      id: ip
      run: |
        IP=$(cat droplet_ip.txt)
        if [ -z "$IP" ]; then
          echo "‚ùå ERRO: IP n√£o encontrado no artifact droplet-ip"
          exit 1
        fi
        echo "DROPLET_IP=$IP" >> $GITHUB_ENV
        echo "üì° Conectando ao servidor: $IP"

    - name: Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ env.DROPLET_IP }} >> ~/.ssh/known_hosts

    - name: Deploy to server
      run: |
        echo "=== Iniciando Deploy no IP: ${{ env.DROPLET_IP }} ==="
        
        # Copia arquivos necess√°rios
        scp -i ~/.ssh/id_rsa docker-compose.prod.yml root@${{ env.DROPLET_IP }}:/opt/projeto-devops/
        scp -i ~/.ssh/id_rsa .env.example root@${{ env.DROPLET_IP }}:/opt/projeto-devops/.env 2>/dev/null || true
        
        # Executa deploy via SSH
        ssh -i ~/.ssh/id_rsa root@${{ env.DROPLET_IP }} "
          echo '=== Atualizando c√≥digo ==='
          cd /opt/projeto-devops
          git pull origin main 2>/dev/null || git clone https://github.com/caioegc/projeto-devops.git /opt/projeto-devops
          
          echo '=== Fazendo deploy da nova imagem ==='
          export DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          export IMAGE_TAG=${{ github.sha }}
          
          docker-compose -f docker-compose.prod.yml pull app
          docker-compose -f docker-compose.prod.yml down
          docker-compose -f docker-compose.prod.yml up -d
          
          echo '=== Verificando containers ==='
          docker ps
          
          echo '=== Deploy conclu√≠do ==='
        "
